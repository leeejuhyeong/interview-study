# 트랜잭션
## 목차
## 1. 트랜잭션 정의
### 2. Isolation Level
### 3. 동시성 제어(락 메커니즘)
### 4. 교착상태(Dead Lock)와 회복(Recovery)
  
  
# 트랜잭션 정의
## 요약
- 트랜잭션이란 데이터베이스의 상태를 변화시키기 위해서 수행하는 더 이상 쪼갤 수 없는 최소 작업 단위를 의미
- 원자성, 일관성, 독립성(격리성), 지속성(영속성) 4가지의 특징을 갖고있음
- Commit, Rollback
  
  
## 트랜잭션이란
- Commit, Rollback
- 데이터베이스의 상태를 변화시키기 위해서 수행하는 작업의 단위
- 작업단위는 질의어 한문장이 아닌 개발자가 정하는 작업 -> 더 이상 쪼갤 수 없는 최소 단위
	- Ex) 게시판 글 작성하면 게시글을 보여준다 -> Insert 후 select로 게시글까지 가져오는 것이 1개의 작업!
- 여러 작업을 진행하다가 문제가 생겼을 경우 이전 상태로 롤백하기 위해 사용
  
  
## 트랜잭션의 동작
![인덱싱_해쉬](https://github.com/leeejuhyeong/images/blob/main/no-study-no-future/Database/transaction-status.png?raw=true)  
- 활동(Active) : 여러 개의 연산을 수행중
- 부분완료(Partially Committed) : 마지막 연산까지 끝나고 Commit(완료)를 하기 전
  
  
## 트랜잭션의 특징(ACID)
### 원자성(Atomicity)
- 트랜잭션은 데이터베이스에 모두 반영되거나 전혀 반영되지 않아야 한다
- 작업 중 모든 명령이 완벽히 수행되어야하며, 하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 함
  
### 일관성(Consistency)
- 트랜잭션의 작업 완료되더라도 일관성 있는 데이터베이스 상태여야 함
- 트랜잭션 진행 중 데이터베이스가 변경되더라도 ~업데이트된 데이터베이스로 트랜잭션이 진행되는 것이 아닌~, **처음에 트랜잭션을 진행하기 위해 참조한 데이터베이스로 진행**
  
### 독립성, 격리성(Isolation)
- 둘 이상의 트랜잭션이 동시에 병행 실행될 때, 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없음
- 수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없음
- 예시
```
A의 잔액이 50,000원이라고 하고 트랜잭션1은 A가 B에게 10,000원을 송금하는 작업이고 트랜잭션2는 READ를  두 번하는 작업이라고 가정합니다. 트랜잭션1이 동작하는 와중에 A의 통장잔액이 40,000원이 된 후 트랜잭션2가 A의 통장잔액(40,000원)을 읽습니다. 그 후에 트랜잭션1이 취소되어 A의 잔액을 50,000원을 만들었고 트랜잭션2가 다시 읽었을 때는 A의 통장잔액(50,000원)을 읽습니다.
```
	- 위와 같은 상황을 Dirty Read(커밋되지 않은 읽기)라고 부름
- **트랜잭션 격리(고립) 수준(Isolation Level)**
	- 추후 정리
  
### 지속성, 영속성(Durability)
- 트랜잭션이 성공적으로 완료되면, 결과는 영구적으로 반영되어야 함
  
  
## 트랜잭션 연산
### Commit 연산
- 하나의 트랜잭션이 성공적으로 끝났고, 데이터베이스가 일관성있는 상태에 있을 때, 이를 알려주기 위해 사용하는 연산
- commit 사용 시, 수행했던 트랜잭션이 로그에 저장
  
### Rollback 연산
- 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성이 깨진 경우 발생
- 트랜잭션이 일부가 정상적으로 처리되었더라도 이 트랜잭션이 행한 모든 연산은 취소(Undo)된다
  
  
> Spring은 트랜잭션을 AOP로 설정해서 편리하게 관리해줍니다.  
> 추후 정리 예정  